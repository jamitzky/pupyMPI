from mpi.logger import Logger

def parse_hostfile(hostfile): # {{{1
    """
    Parses hostfile, and returns list of tuples of the form (hostname, hostparameters_in_dict)
    NOTE: Standard port below and maybe other defaults should not be hardcoded here
    (defaults should probably be a parameter for this function)
    """
    logger = Logger()

    defaults = {"cpu":1,"max_cpu":1024,"port":14000}
    # TODO: Something must be intended with the malformed flag but I can't find usage,
    #       what do we do about malformed hostfiles?
    malformed = False # Flag bad hostfile
    hosts = []
    
    try:
        fh = open(hostfile, "r")
        for line in fh.readlines():
            pseudo_list = line.split( "#", 1 )            
            content = pseudo_list[0] # the comment would be pseudo_list[1] but those are ignored
            if content <> '\n' and content <> '': # Ignore empty lines and lines that are all comment
                values = content.split() # split on whitespace with multiple spaces ignored
                # There is always a hostname
                hostname = values[0]
                specified = defaults.copy()
                                
                # Check if non-defaults were specified
                values = values[1:] # Ignore hostname we already know that
                for v in values:
                    (key,separator,val) = v.partition('=')
                    if separator == '': # empty if malformed key-value pair
                        malformed = True
                    elif not defaults.has_key(key): # unrecognized keys are considered malformed
                        malformed = True
                    else:                        
                        specified[key] = int(val)
                        #NOTE: Should check for value type here (probably non-int = malformed for now)
                
                hosts += [(hostname, specified)]

        fh.close()
    except:
        logger.info("No hostfile specified or hostfile invalid - all processes will run on default machines (typically localhost)")
        hosts = [("localhost",defaults)]
    
    return hosts
            

def map_hostfile(hosts, np=1, type="rr", overmapping=True): # {{{1
    """
    Assign ranks and host to all processes
    NOTE: We only do primitive overcommitting so far.
    Eventually we should decide how to best map more processes than "cpu" specifies, onto hosts
    eg. does higher cpu/max_cpu ratio mean a more realistic estimate of a good max cpu?
    """
    logger = Logger()

    mappedHosts = [] # list containing the (host,rank) tuples to return   
    hostCount = len(hosts) # How many hosts do we have
        
    # Check viability of mapping np onto all CPUs from all hosts
    actualCPUs = 0 # Real physical CPUs
    maxCPUs = 0 # Allowed overmapped CPUs
    for (hostname,params) in hosts:
        actualCPUs += params["cpu"]
        maxCPUs += params["max_cpu"]

    # Check if it can be done with or without overmapping
    if actualCPUs >= np:  # No need to overmap
        pass
    elif maxCPUs >= np: # Overmapping is needed
        if overmapping: # Overmapping allowed?
            logger.info("Insufficient hosts - overmapping processes.")
        else: # Overmapping needed but not allowed
            logger.info("Number of processes exceeds the total CPUs and overmapping is not allowed")
            return []
    else: # Can't be done even with overmapping
        logger.info("Number of processes exceeds the maximum allowed CPUs")
        return []
        
    i = 0 # host indexer
    rank = 0 # rank counter
    mapType = "cpu" # Start by mapping only on actual CPUs (non-overmapping)
    
    while rank < actualCPUs and rank < np: # Assign to actual CPUs until no more CPUs (or all ranks assigned if not overmapping)
        (hostname,params) = hosts[i%hostCount]
        if params[mapType] > 0: # Are there CPUs available on host?
            params[mapType] -= 1 # mark as one less unused
            params["max_cpu"] -= 1 # max cpu includes actual ones so decrease here too
            mappedHosts += [(hostname, rank, params["port"])] # map it
            rank += 1 # assign next rank
            #DEBUG
            #print "mapped %i to %s" % (rank,hostname)
            
            if type == "rr": # round-robin?
                i += 1 # for round-robin always go to next host
            
        else: # if no CPUs left we always go to next host
            i += 1 # pick next host

    # The overmapping is done in it's own loop since we might wanna do things a bit
    #differently here.
    mapType = "max_cpu"
    while rank < np: # Overmap any remaining ranks until all needed ranks are mapped
        (hostname,params) = hosts[i%hostCount]
        if params[mapType] > 0: # Are there CPUs available on host?
            params[mapType] -= 1 # mark as one less unused
            mappedHosts += [(hostname, rank, params["port"])] # map it
            rank += 1 # assign next rank
            
            if type == "rr": # round-robin?
                i += 1 # for round-robin always go to next host
            
        else: # if no CPUs left we always go to next host
            i += 1 # pick next host
            
    return mappedHosts
