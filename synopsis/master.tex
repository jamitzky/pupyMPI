\documentclass{article}

\usepackage{fancyhdr}

\begin{document}
\pagestyle{fancy}

\fancyhead[R]{Frederik Hantho\\Asser Schrøder Femø\\Rune Bromer}
\fancyhead[L]{Synopsis\\pupyMPI Reloaded\\4. May 2010}
\setlength\headheight{2cm}

\noindent
\textbf{Project title:} pupyMPI Reloaded - Bigger. Faster. Uncut.\\

\noindent
\textbf{Authors:} Frederik Hantho, Asser Schrøder Femø\& Rune Bromer\\

\noindent
\textbf{Project consultant:} Brian Vinter\\

\noindent
\textbf{ECTS:} 7.5\\


\section*{Background}
The demand for easy, highly scalable, parallel computing is growing daily as
many-core systems become prevalent. The Message Passing Interface (MPI) is a
widely used and globally accepted model for expressing parallelism. The success
of MPI stems from its portability, completeness and performance i.r.t. massively
parallel programs, amongst others. However, MPI is generally not considered
simple, nor easy to program, particularly as it is most commonly implemented in
C or FORTRAN. This is a problem since many potential users are not skilled
programmers, but rather researchers who are capable of expressing their
algorithms in a deterministic logical framework.
\\

% 1. Casting af broadcasttræ ifbm. kollektivoperationer
% 2. Sammenligning af socket polling metoder
% 3. Profiling med fine grafer
% 4. Optimering af buffers
% 5. Undgå broadcast af redundant data i kollektivoperationer (reduce/scatter)
% 6. Praktiske kørsler i større miljøer (dikus klynge)
% 7. TCP tuning, socket options (fhantho har en tutorial/paper-ting)

\section*{Motivation}

Improving pupyMPI with an emphasis on performance would seem to have several distinct advantages:

\begin{enumerate}
	\item It's less slow.
	\item Performance analysis tools can help the pupyMPI user to assess
	performance in her program as well as the overhead incurred by pupyMPI and
	communication.
	\item Scaling of MPI collective operations will be helped!
	\item Incorporating user feedback is vital for insuring continued use of pupyMPI
	% XXX: OLD, remove. At some point.
%	\item The advanced type system alleviates the complexities of MPI types as
%Python types can be easily inferred at runtime. 
%	\item Python is standardized across platforms and is either already
%installed, or very easy to install, on almost any major platform of interest to
%HPC users. Python is also highly modular and easy to extend.
%	\item Implementing MPI in native Python means that there is no need to
%maintain a separate native MPI installation, and by extension no need to keep
%specific versions of Python, the MPI wrapper and the MPI library around to
%maintain binary compatibility.
%	\item The low bar to entry to Python means that it is highly useful as a
%prototyping language, and educators can focus on teaching central concepts of
%concurrency, without the clutter of boilerplate code so typical to e.g. C.
\end{enumerate}

\section*{Learning goals}
At the end of the project, we will be able to: 

\begin{itemize}
	\item{ Identify bottlenecks in the existing framework }
	\item{ Design and implement tools to assist in performance analysis and measurement }
	\item{ Reason about lower-level network tuning }
	\item{ Improve performance of Python based high-performance networking applications }
	\item{ Analyze and improve the design of MPI collective operations }
\end{itemize}

\end{document}
